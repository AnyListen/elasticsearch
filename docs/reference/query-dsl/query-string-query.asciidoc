[[query-dsl-query-string-query]]
=== Query String Query

一种使用查询解析器解析其内容的查询。这是一个例子：

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string" : {
            "default_field" : "content",
            "query" : "this AND that OR thus"
        }
    }
}
--------------------------------------------------
// CONSOLE

`query_string` 查询解析输入，并在操作符周围拆分文本。每一个拆分后的文本彼此独立地被解析。
例如下面的查询：

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string" : {
            "default_field" : "content",
            "query" : "(new york city) OR (big apple)"
        }
    }
}
--------------------------------------------------
// CONSOLE

... 将会被拆成 `new york city` 和 `big apple`两部分，
然后每一部分根据为该字段配置的分析器独立地被分析。

WARNING: 空格不会被视为运算符，这意味着 `new york city` 将会原样传给为该字段配置的分析器，
如果这个字段是一个关键字字段，分析器将会把 `new york city` 作为一个单独的词，
并且查询构造器将会在查询中使用这个词。如果你想分别查询每一个词，你需要在词之间加上显示的运算符
（例如： `new AND york AND city`）

当提供多个字段的时候，可以通过 `type` 参数来实现不同效果的查询。
可能的方式在 <<multi-match-types, 这里>> 有描述，默认是 `best_fields` 。

`query_string` 最高级参数包括：

[cols="<,<",options="header",]
|=======================================================================
|参数 |描述
|`query` |实际的查询将被解析。请参考 <<query-string-syntax>>。

|`default_field` |如果没有指定前缀字段，默认是 `index.query.default_field` 的索引设置，
默认是 * 。`*` 会提取映射中符合词查询的所有字段，并过滤元数据字段。当没有前缀字段时，
所有被提取的字段组合在一起构建一个查询。

|`default_operator` |如果没有显示的指定运算符，则使用默认的运算符。例如，使用 `OR` 作为默认的运算符，
 `capital of Hungary` 这个查询会被替换成 `capital OR of OR Hungary` ，
 使用 `AND` 作为默认的运算符，则上面的查询将会被替换成 `capital AND of AND Hungary` 。
 默认是 `OR` 。

|`analyzer` |用于分析查询字符串的分析器的名称。

|`quote_analyzer` |用于分析查询字符串中引用短语的分析器的名称。对于这些部分，
它会覆盖其他使用了 `analyzer` 这个参数或者 <<search-quote-analyzer,`search_quote_analyzer`>>
配置的分析器。

|`allow_leading_wildcard` |当设置 * 或者 `?` 通配符是否被允许作为第一个字符的时候。默认是 `true` 。

|`enable_position_increments` |设置为 `true` 可以在结果查询用启用位置增量。默认是 `true` 。

|`fuzzy_max_expansions` |控制模糊查询可被扩展到的最大词数，默认 `50` 。

|`fuzziness` |设置模糊查询的模糊性。默认是 `AUTO` 。允许的设置，参阅 <<fuzziness>> 。

|`fuzzy_prefix_length` |设置模糊查询时的前缀长度。默认是 `0` 。

|`fuzzy_transpositions` |设置为 `false` 以禁用模糊转置 (`ab` -> `ba`) 。默认是 `true` 。

|`phrase_slop` |设置短语的默认间隔。如果是0，则需要精确匹配短语。默认是 `0` 。

|`boost` |设置查询的权重值。默认 `1.0` 。

|`auto_generate_phrase_queries` |默认 `false` 。

|`analyze_wildcard` |默认情况下，不分析查询字符串中的通配符。通过把这个值设为 `true` ，
将会尽可能的分析这些通配符。

|`max_determinized_states` |限制正则表达式查询时创建自动机状态的数量。
这可以防止太难（例如：指数级难度）的正则表达式。默认10000。

|`minimum_should_match` |在布尔查询结果中，控制多少个 "should" 子句将被匹配。
它可能是一个绝对值（`2`），一个百分比，或者一个 <<query-dsl-minimum-should-match,两者的组合>> 。

|`lenient` | 如果设置为 `true` ，将会忽略掉类型不匹配的异常（如向数字字段提供文本）。

|`time_zone` | 时区将会被应用于任何和日期相关的范围查询。也可参阅
http://www.joda.org/joda-time/apidocs/org/joda/time/DateTimeZone.html[JODA timezone]。

|`quote_field_suffix` | 附加到查询字符串的引用部分的字段的后缀。这允许使用具有不同分析链的字段进行精确匹配。
在 <<mixing-exact-search-with-stemming,这里>> 查看一个全面的例子。

|`auto_generate_synonyms_phrase_query` |是否应该为多个同义词自动生成短语查询。默认 `true` 。

|`all_fields` | 已废弃【6.0.0, `default_field` 被 * 代替】对可以查询的映射中检测到的所有字段执行查询。
当 `_all` 字段被禁用，并且（在索引设置或者请求体中）没有指定 `default_field` ，也没有指定 `fields` 时，
`all_fields` 将默认被使用。

|=======================================================================

When a multi term query is being generated, one can control how it gets
rewritten using the
<<query-dsl-multi-term-rewrite,rewrite>>
parameter.

[float]
==== Default Field

When not explicitly specifying the field to search on in the query
string syntax, the `index.query.default_field` will be used to derive
which field to search on. If the `index.query.default_field` is not specified,
the `query_string` will automatically attempt to determine the existing fields in the index's
mapping that are queryable, and perform the search on those fields. Note that this will not
include nested documents, use a nested query to search those documents.

[float]
==== Multi Field

The `query_string` query can also run against multiple fields. Fields can be
provided via the `"fields"` parameter (example below).

The idea of running the `query_string` query against multiple fields is to
expand each query term to an OR clause like this:

    field1:query_term OR field2:query_term | ...

For example, the following query

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string" : {
            "fields" : ["content", "name"],
            "query" : "this AND that"
        }
    }
}
--------------------------------------------------
// CONSOLE

matches the same words as


[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string": {
            "query": "(content:this OR name:this) AND (content:that OR name:that)"
        }
    }
}
--------------------------------------------------
// CONSOLE

Since several queries are generated from the individual search terms,
combining them is automatically done using a `dis_max` query with a tie_breaker.
For example (the `name` is boosted by 5 using `^5` notation):

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string" : {
            "fields" : ["content", "name^5"],
            "query" : "this AND that OR thus",
            "tie_breaker" : 0
        }
    }
}
--------------------------------------------------
// CONSOLE

Simple wildcard can also be used to search "within" specific inner
elements of the document. For example, if we have a `city` object with
several fields (or inner object with fields) in it, we can automatically
search on all "city" fields:

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string" : {
            "fields" : ["city.*"],
            "query" : "this AND that OR thus"
        }
    }
}
--------------------------------------------------
// CONSOLE

Another option is to provide the wildcard fields search in the query
string itself (properly escaping the `*` sign), for example:
`city.\*:something`:

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string" : {
            "query" : "city.\\*:(this AND that OR thus)"
        }
    }
}
--------------------------------------------------
// CONSOLE

NOTE: Since `\` (backslash) is a special character in json strings, it needs to
be escaped, hence the two backslashes in the above `query_string`.

When running the `query_string` query against multiple fields, the
following additional parameters are allowed:

[cols="<,<",options="header",]
|=======================================================================
|Parameter |Description

|`type` |How the fields should be combined to build the text query.
See <<multi-match-types, types>> for a complete example.
Defaults to `best_fields`

|`tie_breaker` |The disjunction max tie breaker for multi fields.
Defaults to `0`
|=======================================================================

The fields parameter can also include pattern based field names,
allowing to automatically expand to the relevant fields (dynamically
introduced fields included). For example:

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string" : {
            "fields" : ["content", "name.*^5"],
            "query" : "this AND that OR thus"
        }
    }
}
--------------------------------------------------
// CONSOLE

[float]
==== Synonyms

The `query_string` query supports multi-terms synonym expansion with the <<analysis-synonym-graph-tokenfilter,
synonym_graph>> token filter. When this filter is used, the parser creates a phrase query for each multi-terms synonyms.
For example, the following synonym: `"ny, new york" would produce:`

`(ny OR ("new york"))`

It is also possible to match multi terms synonyms with conjunctions instead:

[source,js]
--------------------------------------------------
GET /_search
{
   "query": {
       "query_string" : {
           "default_field": "title",
           "query" : "ny city",
           "auto_generate_synonyms_phrase_query" : false
       }
   }
}
--------------------------------------------------
// CONSOLE

The example above creates a boolean query:

`(ny OR (new AND york)) city)`

that matches documents with the term `ny` or the conjunction `new AND york`.
By default the parameter `auto_generate_synonyms_phrase_query` is set to `true`.

include::query-string-syntax.asciidoc[]
