[[query-dsl-query-string-query]]
=== Query String Query

一种使用查询解析器解析其内容的查询。这是一个例子：

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string" : {
            "default_field" : "content",
            "query" : "this AND that OR thus"
        }
    }
}
--------------------------------------------------
// CONSOLE

`query_string` 查询解析输入，并在操作符周围拆分文本。每一个拆分后的文本彼此独立地被解析。
例如下面的查询：

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string" : {
            "default_field" : "content",
            "query" : "field:new york AND city"
        }
    }
}
--------------------------------------------------
// CONSOLE

... 将被拆分为 `new`， `york` 和 `city`，并且每一部分被独立地解析。当有多个字段时，
可以使用 `type` 参数来改变不同的字段被组合在每一个分割后的文本内部的方式。
 <<multi-match-types, 这里>> 描述了可能的模式，默认是 `best_fields`。

`query_string` 最高级参数包括：

[cols="<,<",options="header",]
|=======================================================================
|Parameter |Description
|`query` |实际的查询将被解析。请参考 <<query-string-syntax>>。

|`default_field` |如果没有指定前缀字段，默认是 `index.query.default_field` 的索引设置，
默认是 `*`。`*` 会提取映射中符合词查询的所有字段，并过滤元数据字段。当没有前缀字段时，
所有被提取的字段组合在一起构建一个查询。

|`default_operator` |The default operator used if no explicit operator
is specified. For example, with a default operator of `OR`, the query
`capital of Hungary` is translated to `capital OR of OR Hungary`, and
with default operator of `AND`, the same query is translated to
`capital AND of AND Hungary`. The default value is `OR`.

|`analyzer` |The analyzer name used to analyze the query string.

|`quote_analyzer` |The name of the analyzer that is used to analyze
quoted phrases in the query string. For those parts, it overrides other
analyzers that are set using the `analyzer` parameter or the
<<search-quote-analyzer,`search_quote_analyzer`>> setting.

|`allow_leading_wildcard` |When set, `*` or `?` are allowed as the first
character. Defaults to `true`.

|`enable_position_increments` |Set to `true` to enable position
increments in result queries. Defaults to `true`.

|`fuzzy_max_expansions` |Controls the number of terms fuzzy queries will
expand to. Defaults to `50`

|`fuzziness` |Set the fuzziness for fuzzy queries. Defaults
to `AUTO`. See <<fuzziness>> for allowed settings.

|`fuzzy_prefix_length` |Set the prefix length for fuzzy queries. Default
is `0`.

|`fuzzy_transpositions` |Set to `false` to disable fuzzy transpositions (`ab` -> `ba`).
Default is `true`.

|`phrase_slop` |Sets the default slop for phrases. If zero, then exact
phrase matches are required. Default value is `0`.

|`boost` |Sets the boost value of the query. Defaults to `1.0`.

|`auto_generate_phrase_queries` |Defaults to `false`.

|`analyze_wildcard` |By default, wildcards terms in a query string are
not analyzed. By setting this value to `true`, a best effort will be
made to analyze those as well.

|`max_determinized_states` |Limit on how many automaton states regexp
queries are allowed to create.  This protects against too-difficult
(e.g. exponentially hard) regexps.  Defaults to 10000.

|`minimum_should_match` |A value controlling how many "should" clauses
in the resulting boolean query should match. It can be an absolute value
(`2`), a percentage (`30%`) or a
<<query-dsl-minimum-should-match,combination of
both>>.

|`lenient` |If set to `true` will cause format based failures (like
providing text to a numeric field) to be ignored.

|`time_zone` | Time Zone to be applied to any range query related to dates. See also
http://www.joda.org/joda-time/apidocs/org/joda/time/DateTimeZone.html[JODA timezone].

|`quote_field_suffix` | A suffix to append to fields for quoted parts of
the query string. This allows to use a field that has a different analysis chain
for exact matching. Look <<mixing-exact-search-with-stemming,here>> for a
comprehensive example.

|`auto_generate_synonyms_phrase_query` |Whether phrase queries should be automatically generated for multi terms synonyms.
Defaults to `true`.

|`all_fields` | deprecated[6.0.0, set `default_field` to `*` instead]
Perform the query on all fields detected in the mapping that can
be queried. Will be used by default when the `_all` field is disabled and no
`default_field` is specified (either in the index settings or in the request
body) and no `fields` are specified.

|=======================================================================

When a multi term query is being generated, one can control how it gets
rewritten using the
<<query-dsl-multi-term-rewrite,rewrite>>
parameter.

[float]
==== Default Field

When not explicitly specifying the field to search on in the query
string syntax, the `index.query.default_field` will be used to derive
which field to search on. If the `index.query.default_field` is not specified,
the `query_string` will automatically attempt to determine the existing fields in the index's
mapping that are queryable, and perform the search on those fields. Note that this will not
include nested documents, use a nested query to search those documents.

[float]
==== Multi Field

The `query_string` query can also run against multiple fields. Fields can be
provided via the `"fields"` parameter (example below).

The idea of running the `query_string` query against multiple fields is to
expand each query term to an OR clause like this:

    field1:query_term OR field2:query_term | ...

For example, the following query

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string" : {
            "fields" : ["content", "name"],
            "query" : "this AND that"
        }
    }
}
--------------------------------------------------
// CONSOLE

matches the same words as


[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string": {
            "query": "(content:this OR name:this) AND (content:that OR name:that)"
        }
    }
}
--------------------------------------------------
// CONSOLE

Since several queries are generated from the individual search terms,
combining them is automatically done using a `dis_max` query with a tie_breaker.
For example (the `name` is boosted by 5 using `^5` notation):

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string" : {
            "fields" : ["content", "name^5"],
            "query" : "this AND that OR thus",
            "tie_breaker" : 0
        }
    }
}
--------------------------------------------------
// CONSOLE

Simple wildcard can also be used to search "within" specific inner
elements of the document. For example, if we have a `city` object with
several fields (or inner object with fields) in it, we can automatically
search on all "city" fields:

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string" : {
            "fields" : ["city.*"],
            "query" : "this AND that OR thus"
        }
    }
}
--------------------------------------------------
// CONSOLE

Another option is to provide the wildcard fields search in the query
string itself (properly escaping the `*` sign), for example:
`city.\*:something`:

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string" : {
            "query" : "city.\\*:(this AND that OR thus)"
        }
    }
}
--------------------------------------------------
// CONSOLE

NOTE: Since `\` (backslash) is a special character in json strings, it needs to
be escaped, hence the two backslashes in the above `query_string`.

When running the `query_string` query against multiple fields, the
following additional parameters are allowed:

[cols="<,<",options="header",]
|=======================================================================
|Parameter |Description

|`type` |How the fields should be combined to build the text query.
See <<multi-match-types, types>> for a complete example.
Defaults to `best_fields`
|=======================================================================


[cols="<,<",options="header",]
|=======================================================================
|Parameter |Description

|`tie_breaker` |The disjunction max tie breaker for multi fields.
Defaults to `0`
|=======================================================================

The fields parameter can also include pattern based field names,
allowing to automatically expand to the relevant fields (dynamically
introduced fields included). For example:

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "query_string" : {
            "fields" : ["content", "name.*^5"],
            "query" : "this AND that OR thus"
        }
    }
}
--------------------------------------------------
// CONSOLE

[float]
==== Synonyms

The `query_string` query supports multi-terms synonym expansion with the <<analysis-synonym-graph-tokenfilter,
synonym_graph>> token filter. When this filter is used, the parser creates a phrase query for each multi-terms synonyms.
For example, the following synonym: `"ny, new york" would produce:`

`(ny OR ("new york"))`

It is also possible to match multi terms synonyms with conjunctions instead:

[source,js]
--------------------------------------------------
GET /_search
{
   "query": {
       "query_string" : {
           "default_field": "title",
           "query" : "ny city",
           "auto_generate_synonyms_phrase_query" : false
       }
   }
}
--------------------------------------------------
// CONSOLE

The example above creates a boolean query:

`(ny OR (new AND york)) city)`

that matches documents with the term `ny` or the conjunction `new AND york`.
By default the parameter `auto_generate_synonyms_phrase_query` is set to `true`.

include::query-string-syntax.asciidoc[]
